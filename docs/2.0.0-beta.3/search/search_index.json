{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome on the Homie for ESP8266 docs.", 
            "title": "Welcome"
        }, 
        {
            "location": "/quickstart/what-is-it/", 
            "text": "Homie for ESP8266 is an ESP8266 for Arduino implementation of \nHomie\n, a thin and simple MQTT convention for the IoT. More than that, it's also a full-featured framework to get started with your IoT project very quickly. Simply put, you don't have to manage yourself the connection/reconnection to the Wi-Fi/MQTT. You don't even have to hard-code credentials in your sketch: this can be done using a simple JSON API. Everything is handled internally, by Homie for ESP8266.\n\n\nYou guessed it, the purpose of Homie for ESP8266 is to simplify the development of connected objects.", 
            "title": "What is it?"
        }, 
        {
            "location": "/quickstart/getting-started/", 
            "text": "This \nGetting Started\n guide assumes you have an ESP8266 board with an user-configurable LED, and an user programmable button, like a NodeMCU DevKit 1.0, for example. These restrictions can be lifted (see next pages).\n\n\nTo use Homie for ESP8266, you will need:\n\n\n\n\nAn ESP8266\n\n\nThe Arduino IDE for ESP8266 (version 2.3.0 minimum)\n\n\nBasic knowledge of the Arduino environment (upload a sketch, import libraries, ...)\n\n\nTo understand \nthe Homie convention\n\n\n\n\nInstalling Homie for ESP8266\n\n\nThere are two ways to install Homie for ESP8266.\n\n\n1a. For the Arduino IDE\n\n\nThere is a YouTube video with instructions:\n\n\n How to install Homie libraries on Arduino IDE\n\n\n\n\n\n\nDownload the \nrelease corresponding to this documentation version\n\n\n\n\n\n\nLoad the \n.zip\n with \nSketch \u2192 Include Library \u2192 Add .ZIP Library\n\n\n\n\n\n\nHomie for ESP8266 has 5 dependencies:\n\n\n\n\nArduinoJson\n \n= 5.0.8\n\n\nBounce2\n\n\nESPAsyncTCP\n \n= \nc8ed544\n\n\nAsyncMqttClient\n\n\nESPAsyncWebServer\n\n\n\n\nSome of them are available through the Arduino IDE, with \nSketch \u2192 Include Library \u2192 Manage Libraries\n. For the others, install it by downloading the \n.zip\n on GitHub.\n\n\n1b. With \nPlatformIO\n\n\nIn a terminal, run \nplatformio lib install 555\n.\n\n\n\n\nNot yet released as stable\n\n\nThe above command is for when the v2 is stable and released. Currently, the latest stable version is 1.5. In the meantime, use the develop branch to get started with the v2, add this in your \nplatformio.ini\n:\n\n\nlib_deps = git+https://github.com/marvinroger/homie-esp8266.git#develop\n\n\n\n\n\n\nDependencies are installed automatically.\n\n\nBare minimum sketch\n\n\n#include\n \nHomie.h\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nSerial\n.\nbegin\n(\n115200\n);\n\n  \nSerial\n \n \nendl\n \n \nendl\n;\n\n\n  \nHomie_setFirmware\n(\nbare-minimum\n,\n \n1.0.0\n);\n \n// The underscore is not a typo! See Magic bytes\n\n  \nHomie\n.\nsetup\n();\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nHomie\n.\nloop\n();\n\n\n}\n\n\n\n\n\nThis is the bare minimum needed for Homie for ESP8266 to work correctly.\n\n\n\n\nLED\n\n\n\nIf you upload this sketch, you will notice the LED of the ESP8266 will light on. This is because you are in \nconfiguration\n mode.\n\n\n\n\nHomie for ESP8266 has 3 modes of operation:\n\n\n\n\n\n\nBy default, the \nconfiguration\n mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks and send the configuration (like the Wi-Fi SSID, the Wi-Fi password, some settings...). Once the device receives the credentials, it boots into \nnormal\n mode.\n\n\n\n\n\n\nThe \nnormal\n mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running...) and it subscribes to the needed MQTT topics. It automatically reconnects to the Wi-Fi and the MQTT when the connection is lost. It also handle the OTA. The device can return to \nconfiguration\n mode in different ways (press of a button or custom function, see \nResetting\n).\n\n\n\n\n\n\nThe \nstandalone\n mode. See \nStandalone mode\n.\n\n\n\n\n\n\n\n\nWarning\n\n\nAs a rule of thumb, never block the device with blocking code for more than 50ms or so.\n Otherwise, you may very probably experience unexpected behaviors.\n\n\n\n\nConnecting to the AP and configuring the device\n\n\nHomie for ESP8266 has spawned a secure AP named \nHomie-xxxxxxxxxxxx\n, like \nHomie-c631f278df44\n. Connect to it.\n\n\n\n\nHardware device ID\n\n\nThis \nc631f278df44\n ID is unique to each device, and you cannot change it (this is actually the MAC address of the station mode). If you flash a new sketch, this ID won't change.\n\n\n\n\nOnce connected, the webserver is available at \nhttp://192.168.123.1\n. Every domain name is resolved by the built-in DNS server to this address. You can then configure the device using the \nHTTP JSON API\n. When the device receives its configuration, it will reboot into \nnormal\n mode.\n\n\nUnderstanding what happens in \nnormal\n mode\n\n\nVisual codes\n\n\nWhen the device boots in \nnormal\n mode, it will start blinking:\n\n\n\n\nLED\n\n\n\nSlowly when connecting to the Wi-Fi\n\n\n\n\n\n\nLED\n\n\n\nFaster when connecting to the MQTT broker\n\n\n\n\nThis way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost.\n\n\nUnder the hood\n\n\nAlthough the sketch looks like it does not do anything, it actually does quite a lot:\n\n\n\n\nIt automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code\n\n\nIt exposes the Homie device on MQTT (as \nbase topic\n/\ndevice ID\n, e.g. \nhomie/c631f278df44\n)\n\n\nIt subscribes to the special OTA and configuration topics, automatically flashing a sketch if available or updating the configuration\n\n\nIt checks for a button press on the ESP8266, to return to \nconfiguration\n mode\n\n\n\n\nCreating an useful sketch\n\n\nNow that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light.\n\n\n LightOnOff.ino\n\n\nAlright, step by step:\n\n\n\n\nWe create a node with an ID of \nlight\n and a type of \nswitch\n with \nHomieNode lightNode(\nlight\n, \nswitch\n)\n\n\nWe set the name and the version of the firmware with \nHomie_setFirmware(\nawesome-light\n ,\n1.0.0\n);\n\n\nWe want our \nlight\n node to advertise an \non\n property, which is settable. We do that with \nlightNode.advertise(\non\n).settable(lightOnHandler);\n. The \nlightOnHandler\n function will be called when the value of this property is changed\n\n\nIn the \nlightOnHandler\n function, we want to update the state of the \nlight\n node. We do this with \nlightNode.setProperty(\non\n).send(\ntrue\n);\n\n\n\n\nIn about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right?\n\n\nCreating a sensor node\n\n\nIn the previous example sketch, we were reacting to property changes. But what if we want, for example, to send a temperature every 5 minutes? We could do this in the Arduino \nloop()\n function. But then, we would have to check if we are in \nnormal\n mode, and we would have to ensure the network connection is up before being able to send anything. Boring.\n\n\nFortunately, Homie for ESP8266 provides an easy way to do that.\n\n\n TemperatureSensor.ino\n\n\nThe only new things here are the \nHomie.setSetupFunction(setupHandler);\n and \nHomie.setLoopFunction(loopHandler);\n calls. The setup function will be called once, when the device is in \nnormal\n mode and the network connection is up. The loop function will be called everytime, when the device is in \nnormal\n mode and the network connection is up. This provides a nice level of abstraction.\n\n\nNow that you understand the basic usage of Homie for ESP8266, you can head on to the next pages to learn about more powerful features like input handlers, the event system and custom settings.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/getting-started/#installing-homie-for-esp8266", 
            "text": "There are two ways to install Homie for ESP8266.", 
            "title": "Installing Homie for ESP8266"
        }, 
        {
            "location": "/quickstart/getting-started/#1a-for-the-arduino-ide", 
            "text": "There is a YouTube video with instructions:   How to install Homie libraries on Arduino IDE    Download the  release corresponding to this documentation version    Load the  .zip  with  Sketch \u2192 Include Library \u2192 Add .ZIP Library    Homie for ESP8266 has 5 dependencies:   ArduinoJson   = 5.0.8  Bounce2  ESPAsyncTCP   =  c8ed544  AsyncMqttClient  ESPAsyncWebServer   Some of them are available through the Arduino IDE, with  Sketch \u2192 Include Library \u2192 Manage Libraries . For the others, install it by downloading the  .zip  on GitHub.", 
            "title": "1a. For the Arduino IDE"
        }, 
        {
            "location": "/quickstart/getting-started/#1b-with-platformio", 
            "text": "In a terminal, run  platformio lib install 555 .   Not yet released as stable  The above command is for when the v2 is stable and released. Currently, the latest stable version is 1.5. In the meantime, use the develop branch to get started with the v2, add this in your  platformio.ini :  lib_deps = git+https://github.com/marvinroger/homie-esp8266.git#develop   Dependencies are installed automatically.", 
            "title": "1b. With PlatformIO"
        }, 
        {
            "location": "/quickstart/getting-started/#bare-minimum-sketch", 
            "text": "#include   Homie.h  void   setup ()   { \n   Serial . begin ( 115200 ); \n   Serial     endl     endl ; \n\n   Homie_setFirmware ( bare-minimum ,   1.0.0 );   // The underscore is not a typo! See Magic bytes \n   Homie . setup ();  }  void   loop ()   { \n   Homie . loop ();  }   This is the bare minimum needed for Homie for ESP8266 to work correctly.   LED  \nIf you upload this sketch, you will notice the LED of the ESP8266 will light on. This is because you are in  configuration  mode.   Homie for ESP8266 has 3 modes of operation:    By default, the  configuration  mode is the initial one. It spawns an AP and an HTTP webserver exposing a JSON API. To interact with it, you have to connect to the AP. Then, an HTTP client can get the list of available Wi-Fi networks and send the configuration (like the Wi-Fi SSID, the Wi-Fi password, some settings...). Once the device receives the credentials, it boots into  normal  mode.    The  normal  mode is the mode the device will be most of the time. It connects to the Wi-Fi, to the MQTT, it sends initial informations to the Homie server (like the local IP, the version of the firmware currently running...) and it subscribes to the needed MQTT topics. It automatically reconnects to the Wi-Fi and the MQTT when the connection is lost. It also handle the OTA. The device can return to  configuration  mode in different ways (press of a button or custom function, see  Resetting ).    The  standalone  mode. See  Standalone mode .     Warning  As a rule of thumb, never block the device with blocking code for more than 50ms or so.  Otherwise, you may very probably experience unexpected behaviors.", 
            "title": "Bare minimum sketch"
        }, 
        {
            "location": "/quickstart/getting-started/#connecting-to-the-ap-and-configuring-the-device", 
            "text": "Homie for ESP8266 has spawned a secure AP named  Homie-xxxxxxxxxxxx , like  Homie-c631f278df44 . Connect to it.   Hardware device ID  This  c631f278df44  ID is unique to each device, and you cannot change it (this is actually the MAC address of the station mode). If you flash a new sketch, this ID won't change.   Once connected, the webserver is available at  http://192.168.123.1 . Every domain name is resolved by the built-in DNS server to this address. You can then configure the device using the  HTTP JSON API . When the device receives its configuration, it will reboot into  normal  mode.", 
            "title": "Connecting to the AP and configuring the device"
        }, 
        {
            "location": "/quickstart/getting-started/#understanding-what-happens-in-normal-mode", 
            "text": "", 
            "title": "Understanding what happens in normal mode"
        }, 
        {
            "location": "/quickstart/getting-started/#visual-codes", 
            "text": "When the device boots in  normal  mode, it will start blinking:   LED  \nSlowly when connecting to the Wi-Fi    LED  \nFaster when connecting to the MQTT broker   This way, you can have a quick feedback on what's going on. If both connections are established, the LED will stay off. Note the device will also blink during the automatic reconnection, if the connection to the Wi-Fi or the MQTT broker is lost.", 
            "title": "Visual codes"
        }, 
        {
            "location": "/quickstart/getting-started/#under-the-hood", 
            "text": "Although the sketch looks like it does not do anything, it actually does quite a lot:   It automatically connects to the Wi-Fi and MQTT broker. No more network boilerplate code  It exposes the Homie device on MQTT (as  base topic / device ID , e.g.  homie/c631f278df44 )  It subscribes to the special OTA and configuration topics, automatically flashing a sketch if available or updating the configuration  It checks for a button press on the ESP8266, to return to  configuration  mode", 
            "title": "Under the hood"
        }, 
        {
            "location": "/quickstart/getting-started/#creating-an-useful-sketch", 
            "text": "Now that we understand how Homie for ESP8266 works, let's create an useful sketch. We want to create a smart light.   LightOnOff.ino  Alright, step by step:   We create a node with an ID of  light  and a type of  switch  with  HomieNode lightNode( light ,  switch )  We set the name and the version of the firmware with  Homie_setFirmware( awesome-light  , 1.0.0 );  We want our  light  node to advertise an  on  property, which is settable. We do that with  lightNode.advertise( on ).settable(lightOnHandler); . The  lightOnHandler  function will be called when the value of this property is changed  In the  lightOnHandler  function, we want to update the state of the  light  node. We do this with  lightNode.setProperty( on ).send( true );   In about thirty SLOC, we have achieved to create a smart light, without any hard-coded credentials, with automatic reconnection in case of network failure, and with OTA support. Not bad, right?", 
            "title": "Creating an useful sketch"
        }, 
        {
            "location": "/quickstart/getting-started/#creating-a-sensor-node", 
            "text": "In the previous example sketch, we were reacting to property changes. But what if we want, for example, to send a temperature every 5 minutes? We could do this in the Arduino  loop()  function. But then, we would have to check if we are in  normal  mode, and we would have to ensure the network connection is up before being able to send anything. Boring.  Fortunately, Homie for ESP8266 provides an easy way to do that.   TemperatureSensor.ino  The only new things here are the  Homie.setSetupFunction(setupHandler);  and  Homie.setLoopFunction(loopHandler);  calls. The setup function will be called once, when the device is in  normal  mode and the network connection is up. The loop function will be called everytime, when the device is in  normal  mode and the network connection is up. This provides a nice level of abstraction.  Now that you understand the basic usage of Homie for ESP8266, you can head on to the next pages to learn about more powerful features like input handlers, the event system and custom settings.", 
            "title": "Creating a sensor node"
        }, 
        {
            "location": "/advanced-usage/built-in-led/", 
            "text": "By default, Homie for ESP8266 will blink the built-in LED to indicate its status. Note it does not indicate activity, only the status of the device (in \nconfiguration\n mode, connecting to Wi-Fi or connecting to MQTT), see \nGetting started\n for more information.\n\n\nHowever, on some boards like the ESP-01, the built-in LED is actually the TX port, so it is fine if Serial is not enabled, but if you enable Serial, this is a problem. You can easily disable the built-in LED blinking.\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\ndisableLedFeedback\n();\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nYou may, instead of completely disable the LED control, set a new LED to control:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetLedPin\n(\n16\n,\n \nHIGH\n);\n \n// before Homie.setup() -- 2nd param is the state of the pin when the LED is o\n\n  \n// ...\n\n\n}", 
            "title": "Built-in LED"
        }, 
        {
            "location": "/advanced-usage/branding/", 
            "text": "By default, Homie for ESP8266 will spawn an \nHomie-xxxxxxxxxxxx\n AP and will connect to the MQTT broker with the \nHomie-xxxxxxxxxxxx\n client ID. You might want to change the \nHomie\n text:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie_setBrand\n(\nMyIoTSystem\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}", 
            "title": "Branding"
        }, 
        {
            "location": "/advanced-usage/events/", 
            "text": "You may want to hook to Homie events. Maybe you will want to control an RGB LED if the Wi-Fi connection is lost, or execute some code prior to a device reset, for example to clear some EEPROM you're using:\n\n\nvoid\n \nonHomieEvent\n(\nconst\n \nHomieEvent\n \nevent\n)\n \n{\n\n  \nswitch\n(\nevent\n.\ntype\n)\n \n{\n\n    \ncase\n \nHomieEventType\n::\nSTANDALONE_MODE\n:\n\n      \n// Do whatever you want when standalone mode is started\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nCONFIGURATION_MODE\n:\n\n      \n// Do whatever you want when configuration mode is started\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nNORMAL_MODE\n:\n\n      \n// Do whatever you want when normal mode is started\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nOTA_STARTED\n:\n\n      \n// Do whatever you want when OTA is started\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nOTA_PROGRESS\n:\n\n      \n// Do whatever you want when OTA is in progress\n\n\n      \n// You can use event.sizeDone and event.sizeTotal\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nOTA_FAILED\n:\n\n      \n// Do whatever you want when OTA is failed\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nOTA_SUCCESSFUL\n:\n\n      \n// Do whatever you want when OTA is successful\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nABOUT_TO_RESET\n:\n\n      \n// Do whatever you want when the device is about to reset\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nWIFI_CONNECTED\n:\n\n      \n// Do whatever you want when Wi-Fi is connected in normal mode\n\n\n      \n// You can use event.ip, event.gateway, event.mask\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nWIFI_DISCONNECTED\n:\n\n      \n// Do whatever you want when Wi-Fi is disconnected in normal mode\n\n\n      \n// You can use event.wifiReason\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nMQTT_READY\n:\n\n      \n// Do whatever you want when MQTT is connected in normal mode\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nMQTT_DISCONNECTED\n:\n\n      \n// Do whatever you want when MQTT is disconnected in normal mode\n\n\n      \n// You can use event.mqttReason\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nMQTT_PACKET_ACKNOWLEDGED\n:\n\n      \n// Do whatever you want when an MQTT packet with QoS \n 0 is acknowledged by the broker\n\n\n      \n// You can use event.packetId\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nREADY_TO_SLEEP\n:\n\n      \n// After you\nve called `prepareToSleep()`, the event is triggered when MQTT is disconnected\n\n      \nbreak\n;\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nonEvent\n(\nonHomieEvent\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nSee the following example for a concrete use case:\n\n\n HookToEvents.ino", 
            "title": "Events"
        }, 
        {
            "location": "/advanced-usage/logging/", 
            "text": "By default, Homie for ESP8266 will output a lot of useful debug messages on the Serial. You may want to disable this behavior if you want to use the Serial line for anything else.\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\ndisableLogging\n();\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\nWarning\n\n\nIt's up to you to call \nSerial.begin();\n, whether logging is enabled or not.\n\n\n\n\nYou can also change the \nPrint\n instance to log to:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetLoggingPrinter\n(\nSerial2\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nYou can use the logger from your code with the \ngetLogger()\n client:\n\n\nHomie\n.\ngetLogger\n()\n \n \nHey!\n \n \nendl\n;", 
            "title": "Logging"
        }, 
        {
            "location": "/advanced-usage/streaming-operator/", 
            "text": "Homie for ESP8266 includes a nice streaming operator to interact with \nPrint\n objects.\n\n\nImagine the following code:\n\n\nint\n \ntemperature\n \n=\n \n32\n;\n\n\nHomie\n.\ngetLogger\n().\nprint\n(\nThe current temperature is \n);\n\n\nHomie\n.\ngetLogger\n().\nprint\n(\ntemperature\n);\n\n\nHomie\n.\ngetLogger\n().\nprintln\n(\n \u00b0C.\n);\n\n\n\n\n\nWith the streaming operator, the following code will do exactly the same thing, without performance penalties:\n\n\nint\n \ntemperature\n \n=\n \n32\n;\n\n\nHomie\n.\ngetLogger\n()\n \n \nThe current temperature is \n \n \ntemperature\n \n \n \u00b0C.\n \n \nendl\n;", 
            "title": "Streaming operator"
        }, 
        {
            "location": "/advanced-usage/input-handlers/", 
            "text": "There are four types of input handlers:\n\n\n\n\nGlobal input handler. This unique handler will handle every changed settable properties for all nodes\n\n\n\n\nbool\n \nglobalInputHandler\n(\nconst\n \nHomieNode\n \nnode\n,\n \nconst\n \nString\n \nproperty\n,\n \nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetGlobalInputHandler\n(\nglobalInputHandler\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\nNode input handlers. This handler will handle every changed settable properties of a specific node\n\n\n\n\nbool\n \nnodeInputHandler\n(\nconst\n \nString\n \nproperty\n,\n \nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n\n\n}\n\n\n\nHomieNode\n \nnode\n(\nid\n,\n \ntype\n,\n \nnodeInputHandler\n);\n\n\n\n\n\n\n\nVirtual callback from node input handler\n\n\n\n\nYou can create your own class derived from HomieNode that implements the virtual method \nbool HomieNode::handleInput(const String\n property, const String\n value)\n. The default node input handler then automatically calls your callback.\n\n\nclass\n \nRelaisNode\n \n:\n \npublic\n \nHomieNode\n \n{\n\n \npublic\n:\n\n    \nRelaisNode\n()\n:\n \nHomieNode\n(\nRelais\n,\n \nswitch8\n);\n\n\n \nprotected\n:\n\n  \nvirtual\n \nbool\n \nhandleInput\n(\nconst\n \nString\n \nproperty\n,\n \nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n\n  \n}\n\n\n};\n\n\n\n\n\n\n\nProperty input handlers. This handler will handle changes for a specific settable property of a specific node\n\n\n\n\nbool\n \npropertyInputHandler\n(\nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n\n\n}\n\n\n\nHomieNode\n \nnode\n(\nid\n,\n \ntype\n);\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nnode\n.\nadvertise\n(\nproperty\n).\nsettable\n(\npropertyInputHandler\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nYou can see that input handlers return a boolean. An input handler can decide whether or not it handled the message and want to propagate it down to other input handlers. If an input handler returns \ntrue\n, the propagation is stopped, if it returns \nfalse\n, the propagation continues. The order of propagation is global handler \u2192 node handler \u2192 property handler.\n\n\nFor example, imagine you defined three input handlers: the global one, the node one, and the property one. If the global input handler returns \nfalse\n, the node input handler will be called. If the node input handler returns \ntrue\n, the propagation is stopped and the property input handler won't be called. You can think of it as middlewares.\n\n\n\n\nWarning\n\n\nHomie uses \nESPAsyncTCP\n for network communication that make uses of asynchronous callback from the ESP8266 framework for incoming network packets. Thus the input handler runs in a different task than the \nloopHandler()\n. So keep in mind that the network task may interrupt your loop at any time.", 
            "title": "Input handlers"
        }, 
        {
            "location": "/advanced-usage/broadcast/", 
            "text": "Your device can react to Homie broadcasts. To do that, you can use a broadcast handler:\n\n\nbool\n \nbroadcastHandler\n(\nconst\n \nString\n \nlevel\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n  \nSerial\n \n \nReceived broadcast level \n \n \nlevel\n \n \n: \n \n \nvalue\n \n \nendl\n;\n\n  \nreturn\n \ntrue\n;\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetBroadcastHandler\n(\nbroadcastHandler\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}", 
            "title": "Broadcast"
        }, 
        {
            "location": "/advanced-usage/custom-settings/", 
            "text": "Homie for ESP8266 lets you implement custom settings that can be set from the JSON configuration file and the Configuration API. Below is an example of how to use this feature:\n\n\nHomieSetting\nlong\n \npercentageSetting\n(\npercentage\n,\n \nA simple percentage\n);\n  \n// id, description\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \npercentageSetting\n.\nsetDefaultValue\n(\n50\n).\nsetValidator\n([]\n \n(\nlong\n \ncandidate\n)\n \n{\n\n    \nreturn\n \n(\ncandidate\n \n=\n \n0\n)\n \n \n(\ncandidate\n \n=\n \n100\n);\n\n  \n});\n\n\n  \nHomie\n.\nsetup\n();\n\n\n}\n\n\n\n\n\nAn \nHomieSetting\n instance can be of the following types:\n\n\n\n\n\n\n\n\nType\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nbool\n\n\ntrue\n or \nfalse\n\n\n\n\n\n\nlong\n\n\nAn integer from \n-2,147,483,648\n to \n2,147,483,647\n\n\n\n\n\n\ndouble\n\n\nA floating number that can fit into a \nreal64_t\n\n\n\n\n\n\nconst char*\n\n\nAny string\n\n\n\n\n\n\n\n\nBy default, a setting is mandatory (you have to set it in the configuration file). If you give it a default value with \nsetDefaultValue()\n, the setting becomes optional. You can validate a setting by giving a validator function to \nsetValidator()\n. To get the setting from your code, use \nget()\n. To get whether the value returned is the optional one or the one provided, use \nwasProvided()\n.\n\n\nFor this example, if you want to provide the \npercentage\n setting, you will have to put in your configuration file:\n\n\n{\n\n  \nsettings\n:\n \n{\n\n    \npercentage\n:\n \n75\n\n  \n}\n\n\n}\n\n\n\n\n\nSee the following example for a concrete use case:\n\n\n CustomSettings.ino", 
            "title": "Custom settings"
        }, 
        {
            "location": "/advanced-usage/resetting/", 
            "text": "Resetting the device means erasing the stored configuration and rebooting from \nnormal\n mode to \nconfiguration\n mode. By default, you can do it by pressing for 5 seconds the \nFLASH\n button of your ESP8266 board.\n\n\nThis behavior is configurable:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetResetTrigger\n(\n1\n,\n \nLOW\n,\n \n2000\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nThe device will now reset if pin \n1\n is \nLOW\n for \n2000\nms. You can also disable completely this reset trigger:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\ndisableResetTrigger\n();\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nIn addition, you can also trigger a device reset from your sketch:\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nHomie\n.\nreset\n();\n\n\n}\n\n\n\n\n\nThis will reset the device as soon as it is idle. Indeed, sometimes, you might want to disable temporarily the ability to reset the device. For example, if your device is doing some background work like moving shutters, you will want to disable the ability to reset until the shutters are not moving anymore.\n\n\nHomie\n.\nsetIdle\n(\nfalse\n);\n\n\n\n\n\nNote that if a reset is asked while the device is not idle, the device will be flagged. In other words, when you will call \nHomie.setIdle(true);\n back, the device will immediately reset.", 
            "title": "Resetting"
        }, 
        {
            "location": "/advanced-usage/standalone-mode/", 
            "text": "Homie for ESP8266 has a special mode named \nstandalone\n. It was a \nrequested feature\n to implement a way not to boot into \nconfiguration\n mode on initial boot, so that a device can work without being configured first. It was already possible in \nconfiguration\n mode, but the device would spawn an AP which would make it insecure.\n\n\nTo enable this mode, call \nHomie.setStandalone()\n:\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nsetStandalone\n();\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\nTo actually configure the device, you have to reset it, the same way you would to go from \nnormal\n mode to \nconfiguration\n mode.", 
            "title": "Standalone mode"
        }, 
        {
            "location": "/advanced-usage/magic-bytes/", 
            "text": "Homie for ESP8266 firmwares contain magic bytes allowing you to check if a firmware is actually an Homie for ESP8266 firmware, and if so, to get the name, the version and the brand of the firmware.\n\n\nYou might be wondering why \nHomie_setFirmware()\n instead of \nHomie.setFirmware()\n, this is because we use \nspecial macros\n to embed the magic bytes.\n\n\nValues are encoded as such within the firmware binary:\n\n\n\n\n\n\n\n\nType\n\n\nLeft boundary\n\n\nValue\n\n\nRight boundary\n\n\n\n\n\n\n\n\n\n\nHomie magic bytes\n\n\nNone\n\n\n0x25 0x48 0x4F 0x4D 0x49 0x45 0x5F 0x45 0x53 0x50 0x38 0x32 0x36 0x36 0x5F 0x46 0x57 0x25\n\n\nNone\n\n\n\n\n\n\nFirmware name\n\n\n0xBF 0x84 0xE4 0x13 0x54\n\n\nactual firmware name\n\n\n0x93 0x44 0x6B 0xA7 0x75\n\n\n\n\n\n\nFirmware version\n\n\n0x6A 0x3F 0x3E 0x0E 0xE1\n\n\nactual firmware version\n\n\n0xB0 0x30 0x48 0xD4 0x1A\n\n\n\n\n\n\nFirmware brand (only present if \nHomie_setBrand()\n called, Homie otherwise)\n\n\n0xFB 0x2A 0xF5 0x68 0xC0\n\n\nactual firmware brand\n\n\n0x6E 0x2F 0x0F 0xEB 0x2D\n\n\n\n\n\n\n\n\nSee the following script for a concrete use case:\n\n\n firmware_parser.py", 
            "title": "Magic bytes"
        }, 
        {
            "location": "/advanced-usage/range-properties/", 
            "text": "In all the previous examples you have seen, node properties were advertised one-by-one (e.g. \ntemperature\n, \nunit\n...). But what if you have a LED strip with, say, 100 properties, one for each LED? You won't advertise these 100 LEDs one-by-one. This is what range properties are meant for.\n\n\nHomieNode\n \nstripNode\n(\nstrip\n,\n \nstrip\n);\n\n\n\nbool\n \nledHandler\n(\nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \n{\n\n  \nHomie\n.\ngetLogger\n()\n \n \nLED \n \n \nrange\n.\nindex\n \n \n set to \n \n \nvalue\n \n \nendl\n;\n\n\n  \n// Now, let\ns update the actual state of the given led\n\n  \nstripNode\n.\nsetProperty\n(\nled\n).\nsetRange\n(\nrange\n).\nsend\n(\nvalue\n);\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nstripNode\n.\nadvertiseRange\n(\nled\n,\n \n1\n,\n \n100\n).\nsettable\n(\nledHandler\n);\n\n  \n// before Homie.setup()\n\n\n}\n\n\n\n\n\nOn the mqtt broker you will see the following message show up:\n\ntopic                               message\n--------------------------------------------------------\nhomie/\ndevice id\n/strip/$type         strip\nhomie/\ndevice id\n/strip/$properties led[1-100]:settable\n\n\n\nYou can then publish the value \non\n to topic \nhomie/\ndevice id\n/strip/led_1/set\n to turn on led number 1.\n\n\nSee the following example for a concrete use case:\n\n\n LedStrip", 
            "title": "Range properties"
        }, 
        {
            "location": "/advanced-usage/deep-sleep/", 
            "text": "Before deep sleeping, you will want to ensure that all messages are sent, including the \n$online \u2192  false\n. To do that, you can call \nHomie.prepareToSleep()\n. This will disconnect everything cleanly, so that you can call \nESP.deepSleep()\n.\n\n\n#include\n \nHomie.h\n\n\n\nvoid\n \nonHomieEvent\n(\nconst\n \nHomieEvent\n \nevent\n)\n \n{\n\n  \nswitch\n(\nevent\n.\ntype\n)\n \n{\n\n    \ncase\n \nHomieEventType\n::\nMQTT_READY\n:\n\n      \nHomie\n.\ngetLogger\n()\n \n \nMQTT connected, preparing for deep sleep...\n \n \nendl\n;\n\n      \nHomie\n.\nprepareToSleep\n();\n\n      \nbreak\n;\n\n    \ncase\n \nHomieEventType\n::\nREADY_TO_SLEEP\n:\n\n      \nHomie\n.\ngetLogger\n()\n \n \nReady to sleep\n \n \nendl\n;\n\n      \nHomie\n.\ndoDeepSleep\n();\n\n      \nbreak\n;\n\n  \n}\n\n\n}\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nSerial\n.\nbegin\n(\n115200\n);\n\n  \nSerial\n \n \nendl\n \n \nendl\n;\n\n  \nHomie\n.\nonEvent\n(\nonHomieEvent\n);\n\n  \nHomie\n.\nsetup\n();\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nHomie\n.\nloop\n();\n\n\n}", 
            "title": "Deep sleep"
        }, 
        {
            "location": "/advanced-usage/miscellaneous/", 
            "text": "Know if the device is configured / connected\n\n\nIf, for some reason, you want to run some code in the Arduino \nloop()\n function, it might be useful for you to know if the device is in configured (so in \nnormal\n mode) and if the network connection is up.\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nif\n \n(\nHomie\n.\nisConfigured\n())\n \n{\n\n    \n// The device is configured, in normal mode\n\n    \nif\n \n(\nHomie\n.\nisConnected\n())\n \n{\n\n      \n// The device is connected\n\n    \n}\n \nelse\n \n{\n\n      \n// The device is not connected\n\n    \n}\n\n  \n}\n \nelse\n \n{\n\n    \n// The device is not configured, in either configuration or standalone mode\n\n  \n}\n\n\n}\n\n\n\n\n\nGet access to the configuration\n\n\nYou can get access to the configuration of the device. The representation of the configuration is:\n\n\nstruct\n \nConfigStruct\n \n{\n\n  \nchar\n*\n \nname\n;\n\n  \nchar\n*\n \ndeviceId\n;\n\n\n  \nstruct\n \nWiFi\n \n{\n\n    \nchar\n*\n \nssid\n;\n\n    \nchar\n*\n \npassword\n;\n\n  \n}\n \nwifi\n;\n\n\n  \nstruct\n \nMQTT\n \n{\n\n    \nstruct\n \nServer\n \n{\n\n      \nchar\n*\n \nhost\n;\n\n      \nuint16_t\n \nport\n;\n\n    \n}\n \nserver\n;\n\n    \nchar\n*\n \nbaseTopic\n;\n\n    \nbool\n \nauth\n;\n\n    \nchar\n*\n \nusername\n;\n\n    \nchar\n*\n \npassword\n;\n\n  \n}\n \nmqtt\n;\n\n\n  \nstruct\n \nOTA\n \n{\n\n    \nbool\n \nenabled\n;\n\n  \n}\n \nota\n;\n\n\n};\n\n\n\n\n\nFor example, to access the Wi-Fi SSID, you would do:\n\n\nHomie\n.\ngetConfiguration\n().\nwifi\n.\nssid\n;\n\n\n\n\n\nGet access to the MQTT client\n\n\nYou can get access to the underlying MQTT client. For example, to disconnect from the broker:\n\n\nHomie\n.\ngetMqttClient\n().\ndisconnect\n();", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/advanced-usage/miscellaneous/#know-if-the-device-is-configured-connected", 
            "text": "If, for some reason, you want to run some code in the Arduino  loop()  function, it might be useful for you to know if the device is in configured (so in  normal  mode) and if the network connection is up.  void   loop ()   { \n   if   ( Homie . isConfigured ())   { \n     // The device is configured, in normal mode \n     if   ( Homie . isConnected ())   { \n       // The device is connected \n     }   else   { \n       // The device is not connected \n     } \n   }   else   { \n     // The device is not configured, in either configuration or standalone mode \n   }  }", 
            "title": "Know if the device is configured / connected"
        }, 
        {
            "location": "/advanced-usage/miscellaneous/#get-access-to-the-configuration", 
            "text": "You can get access to the configuration of the device. The representation of the configuration is:  struct   ConfigStruct   { \n   char *   name ; \n   char *   deviceId ; \n\n   struct   WiFi   { \n     char *   ssid ; \n     char *   password ; \n   }   wifi ; \n\n   struct   MQTT   { \n     struct   Server   { \n       char *   host ; \n       uint16_t   port ; \n     }   server ; \n     char *   baseTopic ; \n     bool   auth ; \n     char *   username ; \n     char *   password ; \n   }   mqtt ; \n\n   struct   OTA   { \n     bool   enabled ; \n   }   ota ;  };   For example, to access the Wi-Fi SSID, you would do:  Homie . getConfiguration (). wifi . ssid ;", 
            "title": "Get access to the configuration"
        }, 
        {
            "location": "/advanced-usage/miscellaneous/#get-access-to-the-mqtt-client", 
            "text": "You can get access to the underlying MQTT client. For example, to disconnect from the broker:  Homie . getMqttClient (). disconnect ();", 
            "title": "Get access to the MQTT client"
        }, 
        {
            "location": "/advanced-usage/ui-bundle/", 
            "text": "The Homie for ESP8266 configuration AP implements a captive portal. When connecting to it, you will be prompted to connect, and your Web browser will open. By default, it will show an empty page with a text saying to install an \nui_bundle.gz\n file.\n\n\nIndeed, you can serve the \nconfiguration UI\n directly from your ESP8266. See \nthe data/homie folder\n.", 
            "title": "UI Bundle"
        }, 
        {
            "location": "/configuration/json-configuration-file/", 
            "text": "To configure your device, you have two choices: manually flashing the configuration file to the SPIFFS at the \n/homie/config.json\n (see \nUploading files to file system\n), so you can bypass the \nconfiguration\n mode, or send it through the \nHTTP JSON API\n.\n\n\nBelow is the format of the JSON configuration you will have to provide:\n\n\n{\n\n  \nname\n:\n \nThe kitchen light\n,\n\n  \ndevice_id\n:\n \nkitchen-light\n,\n\n  \nwifi\n:\n \n{\n\n    \nssid\n:\n \nNetwork_1\n,\n\n    \npassword\n:\n \nI\nm a Wi-Fi password!\n,\n\n    \nbssid\n:\n \nDE:AD:BE:EF:BA:BE\n,\n\n    \nchannel\n:\n \n1\n,\n\n    \nip\n:\n \n192.168.1.5\n,\n\n    \nmask\n:\n \n255.255.255.0\n,\n\n    \ngw\n:\n \n192.168.1.1\n,\n\n    \ndns1\n:\n \n8.8.8.8\n,\n\n    \ndns2\n:\n \n8.8.4.4\n\n  \n},\n\n  \nmqtt\n:\n \n{\n\n    \nhost\n:\n \n192.168.1.10\n,\n\n    \nport\n:\n \n1883\n,\n\n    \nbase_topic\n:\n \ndevices/\n,\n\n    \nauth\n:\n \ntrue\n,\n\n    \nusername\n:\n \nuser\n,\n\n    \npassword\n:\n \npass\n\n  \n},\n\n  \nota\n:\n \n{\n\n    \nenabled\n:\n \ntrue\n\n  \n},\n\n  \nsettings\n:\n \n{\n\n    \npercentage\n:\n \n55\n\n  \n}\n\n\n}\n\n\n\n\n\nThe above JSON contains every field that can be customized.\n\n\nHere are the rules:\n\n\n\n\nname\n, \nwifi.ssid\n, \nwifi.password\n, \nmqtt.host\n and \nota.enabled\n are mandatory\n\n\nwifi.password\n can be \nnull\n if connecting to an open network\n\n\nIf \nmqtt.auth\n is \ntrue\n, \nmqtt.username\n and \nmqtt.password\n must be provided\n\n\nbssid\n, \nchannel\n, \nip\n, \nmask\n, \ngw\n, \ndns1\n, \ndns2\n are not mandatory and are only needed to if there is a requirement to specify particular AP or set Static IP address. There are some rules which needs to be satisfied:\n\n\nbssid\n and \nchannel\n have to be defined together and these settings are independand of settings related to static IP\n\n\nto define static IP, \nip\n (IP address), \nmask\n (netmask) and \ngw\n (gateway) settings have to be defined at the same time\n\n\nto define second DNS \ndns2\n the first one \ndns1\n has to be defined. Set DNS without \nip\n, \nmask\n and \ngw\n does not affect the configuration (dns server will be provided by DHCP). It is not required to set DNS servers.\n\n\n\n\nDefault values if not provided:\n\n\n\n\ndevice_id\n: the hardware device ID (eg. \n1a2b3c4d5e6f\n)\n\n\nmqtt.port\n: \n1883\n\n\nmqtt.base_topic\n: \nhomie/\n\n\nmqtt.auth\n: \nfalse\n\n\n\n\nThe \nmqtt.host\n field can be either an IP or an hostname.", 
            "title": "JSON configuration file"
        }, 
        {
            "location": "/configuration/http-json-api/", 
            "text": "When in \nconfiguration\n mode, the device exposes a HTTP JSON API to send the configuration to it. When you send a valid configuration to the \n/config\n endpoint, the configuration file is stored in the filesystem at \n/homie/config.json\n.\n\n\nIf you don't want to mess with JSON, you have a Web UI / app available:\n\n\n\n\nAt \nhttp://marvinroger.github.io/homie-esp8266/configurators/v2/\n\n\nAs an \nAndroid app\n\n\n\n\nQuick instructions to use the Web UI / app\n:\n\n\n\n\nOpen the Web UI / app\n\n\nDisconnect from your current Wi-Fi AP, and connect to the \nHomie-xxxxxxxxxxxx\n AP spawned in \nconfiguration\n mode\n\n\nFollow the instructions\n\n\n\n\nYou can see the sources of the Web UI \nhere\n.\n\n\nAlternatively, you can use this \ncurl\n command to send the configuration to the device. You must connect to the device in \nconfiguration\n mode (i.e. the device is an Access Point). This method will not work if not in \nconfiguration\n mode:\n\n\ncurl -X PUT http://192.168.123.1/config --header \nContent-Type: application/json\n -d @config.json\n\n\n\n\nThis will send the \n./config.json\n file to the device.\n\n\nError handling\n\n\nWhen everything went fine, a \n2xx\n HTTP code is returned, such as \n200 OK\n, \n202 Accepted\n, \n204 No Content\n and so on.\nIf anything goes wrong, a return code != 2xx will be returned, with a JSON \nerror\n field indicating the error, such as \n500 Internal Server error\n, \n400 Bad request\n and so on.\n\n\nEndpoints\n\n\nAPI base address:\n \nhttp://192.168.123.1\n\n\nGET \n/heart\nThis is useful to ensure we are connected to the device AP.\nResponse\n204 No Content\n\n\nGET \n/device-info\nGet some information on the device.\nResponse\n200 OK (application/json)\n{\n\n  \nhardware_device_id\n:\n \n52a8fa5d\n,\n\n  \nhomie_esp8266_version\n:\n \n2.0.0\n,\n\n  \nfirmware\n:\n \n{\n\n    \nname\n:\n \nawesome-device\n,\n\n    \nversion\n:\n \n1.0.0\n\n  \n},\n\n  \nnodes\n:\n \n[\n\n    \n{\n\n      \nid\n:\n \nlight\n,\n\n      \ntype\n:\n \nlight\n\n    \n}\n\n  \n],\n\n  \nsettings\n:\n \n[\n\n    \n{\n\n      \nname\n:\n \ntimeout\n,\n\n      \ndescription\n:\n \nTimeout in seconds\n,\n\n      \ntype\n:\n \nulong\n,\n\n      \nrequired\n:\n \nfalse\n,\n\n      \ndefault\n:\n \n10\n\n    \n}\n\n  \n]\n\n\n}\n\n\n\n\ntype\n can be one of the following:\nbool\n: a boolean\nulong\n: an unsigned long\nlong\n: a long\ndouble\n: a double\nstring\n: a string\nNote about settings\nIf a setting is not required, the \ndefault\n field will always be set.\n\n\nGET \n/networks\nRetrieve the Wi-Fi networks the device can see.\nResponse\nIn case of success\n200 OK (application/json)\n{\n\n  \nnetworks\n:\n \n[\n\n    \n{\n \nssid\n:\n \nNetwork_2\n,\n \nrssi\n:\n \n-82\n,\n \nencryption\n:\n \nwep\n \n},\n\n    \n{\n \nssid\n:\n \nNetwork_1\n,\n \nrssi\n:\n \n-57\n,\n \nencryption\n:\n \nwpa\n \n},\n\n    \n{\n \nssid\n:\n \nNetwork_3\n,\n \nrssi\n:\n \n-65\n,\n \nencryption\n:\n \nwpa2\n \n},\n\n    \n{\n \nssid\n:\n \nNetwork_5\n,\n \nrssi\n:\n \n-94\n,\n \nencryption\n:\n \nnone\n \n},\n\n    \n{\n \nssid\n:\n \nNetwork_4\n,\n \nrssi\n:\n \n-89\n,\n \nencryption\n:\n \nauto\n \n}\n\n  \n]\n\n\n}\n\n\n\n\nIn case the initial Wi-Fi scan is not finished on the device\n503 Service Unavailable (application/json)\n{\n\n  \nerror\n:\n \nInitial Wi-Fi scan not finished yet\n\n\n}\n\n\n\n\n\n\nPUT \n/config\nSave the config to the device.\nRequest body\n(application/json)\nSee \nJSON configuration file\n.\nResponse\nIn case of success\n200 OK (application/json)\n{\n\n  \nsuccess\n:\n \ntrue\n\n\n}\n\n\n\n\nIn case of error in the payload\n400 Bad Request (application/json)\n{\n\n  \nsuccess\n:\n \nfalse\n,\n\n  \nerror\n:\n \nReason why the payload is invalid\n\n\n}\n\n\n\n\nIn case the device already received a valid configuration and is waiting for reboot\n403 Forbidden (application/json)\n{\n\n  \nsuccess\n:\n \nfalse\n,\n\n  \nerror\n:\n \nDevice already configured\n\n\n}\n\n\n\n\n\n\nGET \n/wifi/connect\nInitiates the connection of the device to the Wi-Fi network while in configuation mode. This request is not synchronous and the result (Wi-Fi connected or not) must be obtained by with \nGET /wifi/status\n.\nRequest body\n(application/json)\n{\n\n  \nssid\n:\n \nMy_SSID\n,\n\n  \npassword\n:\n \nmy-passw0rd\n\n\n}\n\n\n\n\nResponse\nIn case of success\n202 Accepted (application/json)\n{\n\n  \nsuccess\n:\n \ntrue\n\n\n}\n\n\n\n\nIn case of error in the payload\n400 Bad Request (application/json)\n{\n\n  \nsuccess\n:\n \nfalse\n,\n\n  \nerror\n:\n \nReason why the payload is invalid\n\n\n}\n\n\n\n\n\n\nGET \n/wifi/status\nReturns the current Wi-Fi connection status.\nHelpful when monitoring Wi-Fi connectivity after \nPUT /wifi/connect\n.\nResponse\n200 OK (application/json)\n{\n\n  \nstatus\n:\n \nconnected\n\n\n}\n\n\n\n\nstatus\n might be one of the following:\nidle\nconnect_failed\nconnection_lost\nno_ssid_available\nconnected\n along with a \nlocal_ip\n field\ndisconnected\n\n\nPUT \n/proxy/control\nEnable/disable the device to act as a transparent proxy between AP and Station networks.\nAll requests that don't collide with existing API paths will be bridged to the destination according to the \nHost\n HTTP header. The destination host is called using the existing Wi-Fi connection (established after a \nPUT /wifi/connect\n) and all contents are bridged back to the connection made to the AP side.\nThis feature can be used to help captive portals to perform cloud API calls during device enrollment using the ESP8266 Wi-Fi AP connection without having to patch the Homie firmware. By using the transparent proxy, all operations can be performed by the custom JavaScript running on the browser (in SPIFFS location \n/data/homie/ui_bundle.gz\n).\nHTTPS is not supported.\nImportant\n: The HTTP requests and responses must be kept as small as possible because all contents are transported using RAM memory, which is very limited.\nRequest body\n(application/json)\n{\n\n  \nenable\n:\n \ntrue\n\n\n}\n\n\n\n\nResponse\nIn case of success\n200 OK (application/json)\n{\n\n  \nsuccess\n:\n \ntrue\n\n\n}\n\n\n\n\nIn case of error in the payload\n400 Bad Request (application/json)\n{\n\n  \nsuccess\n:\n \nfalse\n,\n\n  \nerror\n:\n \nReason why the payload is invalid\n\n\n}", 
            "title": "HTTP JSON API"
        }, 
        {
            "location": "/configuration/http-json-api/#error-handling", 
            "text": "When everything went fine, a  2xx  HTTP code is returned, such as  200 OK ,  202 Accepted ,  204 No Content  and so on.\nIf anything goes wrong, a return code != 2xx will be returned, with a JSON  error  field indicating the error, such as  500 Internal Server error ,  400 Bad request  and so on.", 
            "title": "Error handling"
        }, 
        {
            "location": "/configuration/http-json-api/#endpoints", 
            "text": "API base address:   http://192.168.123.1  GET  /heart This is useful to ensure we are connected to the device AP.", 
            "title": "Endpoints"
        }, 
        {
            "location": "/configuration/http-json-api/#response", 
            "text": "204 No Content  GET  /device-info Get some information on the device.", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#response_1", 
            "text": "200 OK (application/json) { \n   hardware_device_id :   52a8fa5d , \n   homie_esp8266_version :   2.0.0 , \n   firmware :   { \n     name :   awesome-device , \n     version :   1.0.0 \n   }, \n   nodes :   [ \n     { \n       id :   light , \n       type :   light \n     } \n   ], \n   settings :   [ \n     { \n       name :   timeout , \n       description :   Timeout in seconds , \n       type :   ulong , \n       required :   false , \n       default :   10 \n     } \n   ]  }   type  can be one of the following: bool : a boolean ulong : an unsigned long long : a long double : a double string : a string Note about settings If a setting is not required, the  default  field will always be set.  GET  /networks Retrieve the Wi-Fi networks the device can see.", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#response_2", 
            "text": "In case of success 200 OK (application/json) { \n   networks :   [ \n     {   ssid :   Network_2 ,   rssi :   -82 ,   encryption :   wep   }, \n     {   ssid :   Network_1 ,   rssi :   -57 ,   encryption :   wpa   }, \n     {   ssid :   Network_3 ,   rssi :   -65 ,   encryption :   wpa2   }, \n     {   ssid :   Network_5 ,   rssi :   -94 ,   encryption :   none   }, \n     {   ssid :   Network_4 ,   rssi :   -89 ,   encryption :   auto   } \n   ]  }   In case the initial Wi-Fi scan is not finished on the device 503 Service Unavailable (application/json) { \n   error :   Initial Wi-Fi scan not finished yet  }    PUT  /config Save the config to the device.", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#request-body", 
            "text": "(application/json) See  JSON configuration file .", 
            "title": "Request body"
        }, 
        {
            "location": "/configuration/http-json-api/#response_3", 
            "text": "In case of success 200 OK (application/json) { \n   success :   true  }   In case of error in the payload 400 Bad Request (application/json) { \n   success :   false , \n   error :   Reason why the payload is invalid  }   In case the device already received a valid configuration and is waiting for reboot 403 Forbidden (application/json) { \n   success :   false , \n   error :   Device already configured  }    GET  /wifi/connect Initiates the connection of the device to the Wi-Fi network while in configuation mode. This request is not synchronous and the result (Wi-Fi connected or not) must be obtained by with  GET /wifi/status .", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#request-body_1", 
            "text": "(application/json) { \n   ssid :   My_SSID , \n   password :   my-passw0rd  }", 
            "title": "Request body"
        }, 
        {
            "location": "/configuration/http-json-api/#response_4", 
            "text": "In case of success 202 Accepted (application/json) { \n   success :   true  }   In case of error in the payload 400 Bad Request (application/json) { \n   success :   false , \n   error :   Reason why the payload is invalid  }    GET  /wifi/status Returns the current Wi-Fi connection status. Helpful when monitoring Wi-Fi connectivity after  PUT /wifi/connect .", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#response_5", 
            "text": "200 OK (application/json) { \n   status :   connected  }   status  might be one of the following: idle connect_failed connection_lost no_ssid_available connected  along with a  local_ip  field disconnected  PUT  /proxy/control Enable/disable the device to act as a transparent proxy between AP and Station networks. All requests that don't collide with existing API paths will be bridged to the destination according to the  Host  HTTP header. The destination host is called using the existing Wi-Fi connection (established after a  PUT /wifi/connect ) and all contents are bridged back to the connection made to the AP side. This feature can be used to help captive portals to perform cloud API calls during device enrollment using the ESP8266 Wi-Fi AP connection without having to patch the Homie firmware. By using the transparent proxy, all operations can be performed by the custom JavaScript running on the browser (in SPIFFS location  /data/homie/ui_bundle.gz ). HTTPS is not supported. Important : The HTTP requests and responses must be kept as small as possible because all contents are transported using RAM memory, which is very limited.", 
            "title": "Response"
        }, 
        {
            "location": "/configuration/http-json-api/#request-body_2", 
            "text": "(application/json) { \n   enable :   true  }", 
            "title": "Request body"
        }, 
        {
            "location": "/configuration/http-json-api/#response_6", 
            "text": "In case of success 200 OK (application/json) { \n   success :   true  }   In case of error in the payload 400 Bad Request (application/json) { \n   success :   false , \n   error :   Reason why the payload is invalid  }", 
            "title": "Response"
        }, 
        {
            "location": "/others/ota-configuration-updates/", 
            "text": "OTA updates\n\n\nHomie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA entity is set up.\n\n\nThere's a script that does just that:\n\n\n ota_updater.py\n\n\nIt works this way:\n\n\n\n\nDuring startup of the Homie for ESP8266 device, it reports the current firmware's MD5 to \n$fw/checksum\n (in addition to \n$fw/name\n and \n$fw/version\n). The OTA entity may or may not use this information to automatically schedule OTA updates\n\n\nThe OTA entity publishes the latest available firmware payload to \n$implementation/ota/firmware/\nmd5 checksum\n, either as binary or as a Base64 encoded string\n\n\nIf OTA is disabled, Homie for ESP8266 reports \n403\n to \n$implementation/ota/status\n and aborts the OTA\n\n\nIf OTA is enabled and the latest available checksum is the same as what is currently running, Homie for ESP8266 reports \n304\n and aborts the OTA\n\n\nIf the checksum is not a valid MD5, Homie for ESP8266 reports \n400 BAD_CHECKSUM\n to \n$implementation/ota/status\n and aborts the OTA\n\n\nHomie starts to flash the firmware\n\n\nThe firmware is updating. Homie for ESP8266 reports progress with \n206 \nbytes written\n/\nbytes total\n\n\nWhen all bytes are flashed, the firmware is verified (including the MD5 if one was set)\n\n\nHomie for ESP8266 either reports \n200\n on success, \n400\n if the firmware in invalid or \n500\n if there's an internal error\n\n\n\n\n\n\nHomie for ESP8266 reboots on success as soon as the device is idle\n\n\n\n\nSee \nHomie implementation specifics\n for more details on status codes.\n\n\nOTA entities projects\n\n\nSee \nCommunity projects\n.\n\n\nConfiguration updates\n\n\nIn \nnormal\n mode, you can get the current \nconfig.json\n, published on \n$implementation/config\n with \nwifi.password\n, \nmqtt.username\n and \nmqtt.password\n stripped. You can update the configuration on-the-fly by publishing incremental JSON updates to \n$implementation/config/set\n. For example, given the following \nconfig.json\n:\n\n\n{\n\n  \nname\n:\n \nKitchen light\n,\n\n  \nwifi\n:\n \n{\n\n    \nssid\n:\n \nNetwork_1\n,\n\n    \npassword\n:\n \nI\nm a Wi-Fi password!\n\n  \n},\n\n  \nmqtt\n:\n \n{\n\n    \nhost\n:\n \n192.168.1.20\n,\n\n    \nport\n:\n \n1883\n\n  \n},\n\n  \nota\n:\n \n{\n\n    \nenabled\n:\n \nfalse\n\n  \n},\n\n  \nsettings\n:\n \n{\n\n\n  \n}\n\n\n}\n\n\n\n\n\nYou can update the name and Wi-Fi password by sending the following incremental JSON:\n\n\n{\n\n  \nname\n:\n \nLiving room light\n,\n\n  \nwifi\n:\n \n{\n\n    \npassword\n:\n \nI\nam a new Wi-Fi password!\n\n  \n}\n\n\n}", 
            "title": "OTA/configuration updates"
        }, 
        {
            "location": "/others/ota-configuration-updates/#ota-updates", 
            "text": "Homie for ESP8266 supports OTA, if enabled in the configuration, and if a compatible OTA entity is set up.  There's a script that does just that:   ota_updater.py  It works this way:   During startup of the Homie for ESP8266 device, it reports the current firmware's MD5 to  $fw/checksum  (in addition to  $fw/name  and  $fw/version ). The OTA entity may or may not use this information to automatically schedule OTA updates  The OTA entity publishes the latest available firmware payload to  $implementation/ota/firmware/ md5 checksum , either as binary or as a Base64 encoded string  If OTA is disabled, Homie for ESP8266 reports  403  to  $implementation/ota/status  and aborts the OTA  If OTA is enabled and the latest available checksum is the same as what is currently running, Homie for ESP8266 reports  304  and aborts the OTA  If the checksum is not a valid MD5, Homie for ESP8266 reports  400 BAD_CHECKSUM  to  $implementation/ota/status  and aborts the OTA  Homie starts to flash the firmware  The firmware is updating. Homie for ESP8266 reports progress with  206  bytes written / bytes total  When all bytes are flashed, the firmware is verified (including the MD5 if one was set)  Homie for ESP8266 either reports  200  on success,  400  if the firmware in invalid or  500  if there's an internal error    Homie for ESP8266 reboots on success as soon as the device is idle   See  Homie implementation specifics  for more details on status codes.", 
            "title": "OTA updates"
        }, 
        {
            "location": "/others/ota-configuration-updates/#ota-entities-projects", 
            "text": "See  Community projects .", 
            "title": "OTA entities projects"
        }, 
        {
            "location": "/others/ota-configuration-updates/#configuration-updates", 
            "text": "In  normal  mode, you can get the current  config.json , published on  $implementation/config  with  wifi.password ,  mqtt.username  and  mqtt.password  stripped. You can update the configuration on-the-fly by publishing incremental JSON updates to  $implementation/config/set . For example, given the following  config.json :  { \n   name :   Kitchen light , \n   wifi :   { \n     ssid :   Network_1 , \n     password :   I m a Wi-Fi password! \n   }, \n   mqtt :   { \n     host :   192.168.1.20 , \n     port :   1883 \n   }, \n   ota :   { \n     enabled :   false \n   }, \n   settings :   { \n\n   }  }   You can update the name and Wi-Fi password by sending the following incremental JSON:  { \n   name :   Living room light , \n   wifi :   { \n     password :   I am a new Wi-Fi password! \n   }  }", 
            "title": "Configuration updates"
        }, 
        {
            "location": "/others/homie-implementation-specifics/", 
            "text": "The Homie \n$implementation\n identifier is \nesp8266\n.\n\n\nVersion\n\n\n\n\n$implementation/version\n: Homie for ESP8266 version\n\n\n\n\nReset\n\n\n\n\n$implementation/reset\n: You can publish a \ntrue\n to this topic to reset the device\n\n\n\n\nConfiguration\n\n\n\n\n$implementation/config\n: The \nconfiguration.json\n is published there, with \nwifi.password\n, \nmqtt.username\n and \nmqtt.password\n fields stripped\n\n\n$implementation/config/set\n: You can update the \nconfiguration.json\n by sending incremental JSON on this topic\n\n\n\n\nOTA\n\n\n\n\n$implementation/ota/enabled\n: \ntrue\n if OTA is enabled, \nfalse\n otherwise\n\n\n$implementation/ota/firmware\n: If the update request is accepted, you must send the firmware payload to this topic\n\n\n$implementation/ota/status\n: HTTP-like status code indicating the status of the OTA. Might be:\n\n\n\n\n\n\n\n\n\n\nCode\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n200\n\n\nOTA successfully flashed\n\n\n\n\n\n\n202\n\n\nOTA request / checksum accepted\n\n\n\n\n\n\n206 465/349680\n\n\nOTA in progress. The data after the status code corresponds to \nbytes written\n/\nbytes total\n\n\n\n\n\n\n304\n\n\nThe current firmware is already up-to-date\n\n\n\n\n\n\n400 BAD_FIRMWARE\n\n\nOTA error from your side. The identifier might be \nBAD_FIRMWARE\n, \nBAD_CHECKSUM\n, \nNOT_ENOUGH_SPACE\n, \nNOT_REQUESTED\n\n\n\n\n\n\n403\n\n\nOTA not enabled\n\n\n\n\n\n\n500 FLASH_ERROR\n\n\nOTA error on the ESP8266. The identifier might be \nFLASH_ERROR", 
            "title": "Homie implementation specifics"
        }, 
        {
            "location": "/others/homie-implementation-specifics/#version", 
            "text": "$implementation/version : Homie for ESP8266 version", 
            "title": "Version"
        }, 
        {
            "location": "/others/homie-implementation-specifics/#reset", 
            "text": "$implementation/reset : You can publish a  true  to this topic to reset the device", 
            "title": "Reset"
        }, 
        {
            "location": "/others/homie-implementation-specifics/#configuration", 
            "text": "$implementation/config : The  configuration.json  is published there, with  wifi.password ,  mqtt.username  and  mqtt.password  fields stripped  $implementation/config/set : You can update the  configuration.json  by sending incremental JSON on this topic", 
            "title": "Configuration"
        }, 
        {
            "location": "/others/homie-implementation-specifics/#ota", 
            "text": "$implementation/ota/enabled :  true  if OTA is enabled,  false  otherwise  $implementation/ota/firmware : If the update request is accepted, you must send the firmware payload to this topic  $implementation/ota/status : HTTP-like status code indicating the status of the OTA. Might be:      Code  Description      200  OTA successfully flashed    202  OTA request / checksum accepted    206 465/349680  OTA in progress. The data after the status code corresponds to  bytes written / bytes total    304  The current firmware is already up-to-date    400 BAD_FIRMWARE  OTA error from your side. The identifier might be  BAD_FIRMWARE ,  BAD_CHECKSUM ,  NOT_ENOUGH_SPACE ,  NOT_REQUESTED    403  OTA not enabled    500 FLASH_ERROR  OTA error on the ESP8266. The identifier might be  FLASH_ERROR", 
            "title": "OTA"
        }, 
        {
            "location": "/others/limitations-and-known-issues/", 
            "text": "SSL support\n\n\nIn Homie for ESP8266 v1.x, SSL was possible but it was not reliable. Due to the asynchronous nature of the v2.x, SSL is not available anymore.\n\n\nADC readings\n\n\nThis is a known esp8266/Arduino issue\n that polling \nanalogRead()\n too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.\n\n\nWi-Fi connection\n\n\nIf you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash. See \n#158\n for more information.", 
            "title": "Limitations and known issues"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#ssl-support", 
            "text": "In Homie for ESP8266 v1.x, SSL was possible but it was not reliable. Due to the asynchronous nature of the v2.x, SSL is not available anymore.", 
            "title": "SSL support"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#adc-readings", 
            "text": "This is a known esp8266/Arduino issue  that polling  analogRead()  too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.", 
            "title": "ADC readings"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#wi-fi-connection", 
            "text": "If you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash. See  #158  for more information.", 
            "title": "Wi-Fi connection"
        }, 
        {
            "location": "/others/troubleshooting/", 
            "text": "1. I see some garbage on the Serial monitor?\n\n\nYou are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things:\n\n\n\n\nDisable the serial logging, to have the LED working:\n\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nenableLogging\n(\nfalse\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\n\n\nDisable the LED blinking, to have the serial line working:\n\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n  \nHomie\n.\nenableBuiltInLedIndicator\n(\nfalse\n);\n \n// before Homie.setup()\n\n  \n// ...\n\n\n}\n\n\n\n\n\n2. I see an \nabort\n message on the Serial monitor?\n\n\nabort()\n is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are:\n\n\n\n\n\n\nYou are calling a function that is meant to be called before \nHomie.setup()\n, after \nHomie.setup()\n\n\n\n\n\n\nOne of the string you've used (in \nsetFirmware()\n, \nsubscribe()\n, etc.) is too long. Check the \nLimits.hpp\n file to see the max length possible for each string.\n\n\n\n\n\n\n3. The network is completely unstable... What's going on?\n\n\nThe framework needs to work continuously (ie. \nHomie.loop()\n needs to be called very frequently). In other words, don't use \ndelay()\n (see \navoid delay\n) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with \nanalogRead()\n, see \nLimitations and known issues\n.\n\n\n4. My device resets itself without me doing anything?\n\n\nYou have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See \nResetting\n.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/others/troubleshooting/#1-i-see-some-garbage-on-the-serial-monitor", 
            "text": "You are probably using a generic ESP8266. The problem with these modules is the built-in LED is tied to the serial line. You can do two things:   Disable the serial logging, to have the LED working:   void   setup ()   { \n   Homie . enableLogging ( false );   // before Homie.setup() \n   // ...  }    Disable the LED blinking, to have the serial line working:   void   setup ()   { \n   Homie . enableBuiltInLedIndicator ( false );   // before Homie.setup() \n   // ...  }", 
            "title": "1. I see some garbage on the Serial monitor?"
        }, 
        {
            "location": "/others/troubleshooting/#2-i-see-an-abort-message-on-the-serial-monitor", 
            "text": "abort()  is called by Homie for ESP8266 when the framework is used in a bad way. The possible causes are:    You are calling a function that is meant to be called before  Homie.setup() , after  Homie.setup()    One of the string you've used (in  setFirmware() ,  subscribe() , etc.) is too long. Check the  Limits.hpp  file to see the max length possible for each string.", 
            "title": "2. I see an abort message on the Serial monitor?"
        }, 
        {
            "location": "/others/troubleshooting/#3-the-network-is-completely-unstable-whats-going-on", 
            "text": "The framework needs to work continuously (ie.  Homie.loop()  needs to be called very frequently). In other words, don't use  delay()  (see  avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with  analogRead() , see  Limitations and known issues .", 
            "title": "3. The network is completely unstable... What's going on?"
        }, 
        {
            "location": "/others/troubleshooting/#4-my-device-resets-itself-without-me-doing-anything", 
            "text": "You have probably connected a sensor to the default reset pin of the framework (D3 on NodeMCU, GPIO0 on other boards). See  Resetting .", 
            "title": "4. My device resets itself without me doing anything?"
        }, 
        {
            "location": "/others/cpp-api-reference/", 
            "text": "Homie\n\n\nYou don't have to instantiate an \nHomie\n instance, it is done internally.\n\n\nvoid\n \nsetup\n();\n\n\n\n\n\nSetup Homie.\n\n\n\n\nMandatory!\n\n\nMust be called once in \nsetup()\n.\n\n\n\n\nvoid\n \nloop\n();\n\n\n\n\n\nHandle Homie work.\n\n\n\n\nMandatory!\n\n\nMust be called once in \nloop()\n.\n\n\n\n\nFunctions to call \nbefore\n \nHomie.setup()\n\n\nvoid\n \nHomie_setFirmware\n(\nconst\n \nchar\n*\n \nname\n,\n \nconst\n \nchar\n*\n \nversion\n);\n\n\n// This is not a typo\n\n\n\n\n\nSet the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version.\n\n\n\n\nMandatory!\n\n\nYou need to set the firmware for your sketch to work.\n\n\n\n\n\n\nname\n: Name of the firmware. Default value is \nundefined\n\n\nversion\n: Version of the firmware. Default value is \nundefined\n\n\n\n\nvoid\n \nHomie_setBrand\n(\nconst\n \nchar\n*\n \nname\n);\n\n\n// This is not a typo\n\n\n\n\n\nSet the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID.\n\n\n\n\nname\n: Name of the brand. Default value is \nHomie\n\n\n\n\nHomie\n \ndisableLogging\n();\n\n\n\n\n\nDisable Homie logging.\n\n\nHomie\n \nsetLoggingPrinter\n(\nPrint\n*\n \nprinter\n);\n\n\n\n\n\nSet the Print instance used for logging.\n\n\n\n\nprinter\n: Print instance to log to. By default, \nSerial\n is used\n\n\n\n\n\n\nWarning\n\n\nIt's up to you to call \nSerial.begin()\n\n\n\n\nHomie\n \ndisableLedFeedback\n();\n\n\n\n\n\nDisable the built-in LED feedback indicating the Homie for ESP8266 state.\n\n\nHomie\n \nsetLedPin\n(\nuint8_t\n \npin\n,\n \nuint8_t\n \non\n);\n\n\n\n\n\nSet pin of the LED to control.\n\n\n\n\npin\n: LED to control\n\n\non\n: state when the light is on (HIGH or LOW)\n\n\n\n\nHomie\n \nsetConfigurationApPassword\n(\nconst\n \nchar\n*\n \npassword\n);\n\n\n\n\n\nSet the configuration AP password.\n\n\n\n\npassword\n: the configuration AP password\n\n\n\n\nHomie\n \nsetGlobalInputHandler\n(\nstd\n::\nfunction\nbool\n(\nconst\n \nString\n \nnodeId\n,\n \nconst\n \nString\n \nproperty\n,\n \nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \nhandler\n);\n\n\n\n\n\nSet input handler for subscribed properties.\n\n\n\n\nhandler\n: Global input handler\n\n\nnode\n: Name of the node getting updated\n\n\nproperty\n: Property of the node getting updated\n\n\nrange\n: Range of the property of the node getting updated\n\n\nvalue\n: Value of the new property\n\n\n\n\nHomie\n \nsetBroadcastHandler\n(\nstd\n::\nfunction\nbool\n(\nconst\n \nString\n \nlevel\n,\n \nconst\n \nString\n \nvalue\n)\n \nhandler\n);\n\n\n\n\n\nSet broadcast handler.\n\n\n\n\nhandler\n: Broadcast handler\n\n\nlevel\n: Level of the broadcast\n\n\nvalue\n: Value of the broadcast\n\n\n\n\nHomie\n \nonEvent\n(\nstd\n::\nfunction\nvoid\n(\nconst\n \nHomieEvent\n \nevent\n)\n \ncallback\n);\n\n\n\n\n\nSet the event handler. Useful if you want to hook to Homie events.\n\n\n\n\ncallback\n: Event handler\n\n\n\n\nHomie\n \nsetResetTrigger\n(\nuint8_t\n \npin\n,\n \nuint8_t\n \nstate\n,\n \nuint16_t\n \ntime\n);\n\n\n\n\n\nSet the reset trigger. By default, the device will reset when pin \n0\n is \nLOW\n for \n5000\nms.\n\n\n\n\npin\n: Pin of the reset trigger\n\n\nstate\n: Reset when the pin reaches this state for the given time\n\n\ntime\n: Time necessary to reset\n\n\n\n\nHomie\n \ndisableResetTrigger\n();\n\n\n\n\n\nDisable the reset trigger.\n\n\nHomie\n \nsetSetupFunction\n(\nstd\n::\nfunction\nvoid\n()\n \ncallback\n);\n\n\n\n\n\nYou can provide the function that will be called when operating in \nnormal\n mode.\n\n\n\n\ncallback\n: Setup function\n\n\n\n\nHomie\n \nsetLoopFunction\n(\nstd\n::\nfunction\nvoid\n()\n \ncallback\n);\n\n\n\n\n\nYou can provide the function that will be looped in normal mode.\n\n\n\n\ncallback\n: Loop function\n\n\n\n\nHomie\n \nsetStandalone\n();\n\n\n\n\n\nThis will mark the Homie firmware as standalone, meaning it will first boot in \nstandalone\n mode. To configure it and boot to \nconfiguration\n mode, the device has to be resetted.\n\n\nFunctions to call \nafter\n \nHomie.setup()\n\n\nvoid\n \nreset\n();\n\n\n\n\n\nFlag the device for reset.\n\n\nvoid\n \nsetIdle\n(\nbool\n \nidle\n);\n\n\n\n\n\nSet the device as idle or not. This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example.\n\n\n\n\nidle\n: Device in an idle state or not\n\n\n\n\nvoid\n \nprepareToSleep\n();\n\n\n\n\n\nPrepare the device for deep sleep. It ensures messages are sent and disconnects cleanly from the MQTT broker, triggering a \nREADY_TO_SLEEP\n event when done.\n\n\nvoid\n \ndoDeepSleep\n(\nuint32_t\n \ntime_us\n \n=\n \n0\n,\n \nRFMode\n \nmode\n \n=\n \nRF_DEFAULT\n);\n\n\n\n\n\nPuth the device into deep sleep. It ensures the Serial is flushed.\n\n\nbool\n \nisConfigured\n()\n \nconst\n;\n\n\n\n\n\nIs the device in \nnormal\n mode, configured?\n\n\nbool\n \nisConnected\n()\n \nconst\n;\n\n\n\n\n\nIs the device in \nnormal\n mode, configured and connected?\n\n\nconst\n \nConfigStruct\n \ngetConfiguration\n()\n \nconst\n;\n\n\n\n\n\nGet the configuration struct.\n\n\n\n\nDanger\n\n\nBe careful with this struct, never attempt to change it.\n\n\n\n\nAsyncMqttClient\n \ngetMqttClient\n();\n\n\n\n\n\nGet the underlying \nAsyncMqttClient\n object.\n\n\nLogger\n \ngetLogger\n();\n\n\n\n\n\nGet the underlying \nLogger\n object, which is only a wrapper around \nSerial\n by default.\n\n\n\n\nHomieNode\n\n\nHomieNode\n(\nconst\n \nchar\n*\n \nid\n,\n \nconst\n \nchar\n*\n \ntype\n,\n \nstd\n::\nfunction\nbool\n(\nconst\n \nString\n \nproperty\n,\n \nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \nhandler\n \n=\n \n);\n\n\n\n\n\nConstructor of an HomieNode object.\n\n\n\n\nid\n: ID of the node\n\n\ntype\n: Type of the node\n\n\nhandler\n: Optional. Input handler of the node\n\n\n\n\nconst\n \nchar\n*\n \ngetId\n()\n \nconst\n;\n\n\n\n\n\nReturn the ID of the node.\n\n\nconst\n \nchar\n*\n \ngetType\n()\n \nconst\n;\n\n\n\n\n\nReturn the type of the node.\n\n\nPropertyInterface\n \nadvertise\n(\nconst\n \nchar\n*\n \nproperty\n);\n\n\nPropertyInterface\n \nadvertiseRange\n(\nconst\n \nchar\n*\n \nproperty\n,\n \nuint16_t\n \nlower\n,\n \nuint16_t\n \nupper\n);\n\n\n\n\n\nAdvertise a property / range property on the node.\n\n\n\n\nproperty\n: Property to advertise\n\n\nlower\n: Lower bound of the range\n\n\nupper\n: Upper bound of the range\n\n\n\n\nThis returns a reference to \nPropertyInterface\n on which you can call:\n\n\nvoid\n \nsettable\n(\nstd\n::\nfunction\nbool\n(\nconst\n \nHomieRange\n \nrange\n,\n \nconst\n \nString\n \nvalue\n)\n \nhandler\n)\n \n=\n \n);\n\n\n\n\n\nMake the property settable.\n\n\n\n\nhandler\n: Optional. Input handler of the property\n\n\n\n\nSendingPromise\n \nsetProperty\n(\nconst\n \nString\n \nproperty\n);\n\n\n\n\n\nUsing this function, you can set the value of a node property, like a temperature for example.\n\n\n\n\nproperty\n: Property to send\n\n\n\n\nThis returns a reference to \nSendingPromise\n, on which you can call:\n\n\nSendingPromise\n \nsetQos\n(\nuint8_t\n \nqos\n);\n  \n// defaults to 1\n\n\nSendingPromise\n \nsetRetained\n(\nbool\n \nretained\n);\n  \n// defaults to true\n\n\nSendingPromise\n \noverwriteSetter\n(\nbool\n \noverwrite\n);\n  \n// defaults to false\n\n\nSendingPromise\n \nsetRange\n(\nconst\n \nHomieRange\n \nrange\n);\n  \n// defaults to not a range\n\n\nSendingPromise\n \nsetRange\n(\nuint16_t\n \nrangeIndex\n);\n  \n// defaults to not a range\n\n\nuint16_t\n \nsend\n(\nconst\n \nString\n \nvalue\n);\n  \n// finally send the property, return the packetId (or 0 if failure)\n\n\n\n\n\nMethod names should be self-explanatory.\n\n\nHomieSetting\n\n\nHomieSetting\nT\n(\nconst\n \nchar\n*\n \nname\n,\n \nconst\n \nchar\n*\n \ndescription\n);\n\n\n\n\n\nConstructor of an HomieSetting object.\n\n\n\n\nT\n: Type of the setting. Either \nbool\n, \nunsigned long\n, \nlong\n, \ndouble\n or \nconst char*\n\n\nname\n: Name of the setting\n\n\ndescription\n: Description of the setting\n\n\n\n\nT\n \nget\n()\n \nconst\n;\n\n\n\n\n\nGet the default value if the setting is optional and not provided, or the provided value if the setting is required or optional but provided.\n\n\nbool\n \nwasProvided\n()\n \nconst\n;\n\n\n\n\n\nReturn whether the setting was provided or not (otherwise \nget()\n would return the default value).\n\n\nSet the default value and make the setting optional.\n\n\nHomieSetting\nT\n \nsetDefaultValue\n(\nT\n \ndefaultValue\n);\n\n\n\n\n\n\n\ndefaultValue\n: The default value\n\n\n\n\nHomieSetting\nT\n \nsetValidator\n(\nstd\n::\nfunction\nbool\n(\nT\n \ncandidate\n)\n \nvalidator\n);\n\n\n\n\n\nSet a validation function for the setting. The validator must return \ntrue\n if the candidate is correct, \nfalse\n otherwise.\n\n\n\n\nvalidator\n: The validation function", 
            "title": "C++ API reference"
        }, 
        {
            "location": "/others/cpp-api-reference/#homie", 
            "text": "You don't have to instantiate an  Homie  instance, it is done internally.  void   setup ();   Setup Homie.   Mandatory!  Must be called once in  setup() .   void   loop ();   Handle Homie work.   Mandatory!  Must be called once in  loop() .", 
            "title": "Homie"
        }, 
        {
            "location": "/others/cpp-api-reference/#functions-to-call-before-homiesetup", 
            "text": "void   Homie_setFirmware ( const   char *   name ,   const   char *   version );  // This is not a typo   Set the name and version of the firmware. This is useful for OTA, as Homie will check against the server if there is a newer version.   Mandatory!  You need to set the firmware for your sketch to work.    name : Name of the firmware. Default value is  undefined  version : Version of the firmware. Default value is  undefined   void   Homie_setBrand ( const   char *   name );  // This is not a typo   Set the brand of the device, used in the configuration AP, the device hostname and the MQTT client ID.   name : Name of the brand. Default value is  Homie   Homie   disableLogging ();   Disable Homie logging.  Homie   setLoggingPrinter ( Print *   printer );   Set the Print instance used for logging.   printer : Print instance to log to. By default,  Serial  is used    Warning  It's up to you to call  Serial.begin()   Homie   disableLedFeedback ();   Disable the built-in LED feedback indicating the Homie for ESP8266 state.  Homie   setLedPin ( uint8_t   pin ,   uint8_t   on );   Set pin of the LED to control.   pin : LED to control  on : state when the light is on (HIGH or LOW)   Homie   setConfigurationApPassword ( const   char *   password );   Set the configuration AP password.   password : the configuration AP password   Homie   setGlobalInputHandler ( std :: function bool ( const   String   nodeId ,   const   String   property ,   const   HomieRange   range ,   const   String   value )   handler );   Set input handler for subscribed properties.   handler : Global input handler  node : Name of the node getting updated  property : Property of the node getting updated  range : Range of the property of the node getting updated  value : Value of the new property   Homie   setBroadcastHandler ( std :: function bool ( const   String   level ,   const   String   value )   handler );   Set broadcast handler.   handler : Broadcast handler  level : Level of the broadcast  value : Value of the broadcast   Homie   onEvent ( std :: function void ( const   HomieEvent   event )   callback );   Set the event handler. Useful if you want to hook to Homie events.   callback : Event handler   Homie   setResetTrigger ( uint8_t   pin ,   uint8_t   state ,   uint16_t   time );   Set the reset trigger. By default, the device will reset when pin  0  is  LOW  for  5000 ms.   pin : Pin of the reset trigger  state : Reset when the pin reaches this state for the given time  time : Time necessary to reset   Homie   disableResetTrigger ();   Disable the reset trigger.  Homie   setSetupFunction ( std :: function void ()   callback );   You can provide the function that will be called when operating in  normal  mode.   callback : Setup function   Homie   setLoopFunction ( std :: function void ()   callback );   You can provide the function that will be looped in normal mode.   callback : Loop function   Homie   setStandalone ();   This will mark the Homie firmware as standalone, meaning it will first boot in  standalone  mode. To configure it and boot to  configuration  mode, the device has to be resetted.", 
            "title": "Functions to call before Homie.setup()"
        }, 
        {
            "location": "/others/cpp-api-reference/#functions-to-call-after-homiesetup", 
            "text": "void   reset ();   Flag the device for reset.  void   setIdle ( bool   idle );   Set the device as idle or not. This is useful at runtime, because you might want the device not to be resettable when you have another library that is doing some unfinished work, like moving shutters for example.   idle : Device in an idle state or not   void   prepareToSleep ();   Prepare the device for deep sleep. It ensures messages are sent and disconnects cleanly from the MQTT broker, triggering a  READY_TO_SLEEP  event when done.  void   doDeepSleep ( uint32_t   time_us   =   0 ,   RFMode   mode   =   RF_DEFAULT );   Puth the device into deep sleep. It ensures the Serial is flushed.  bool   isConfigured ()   const ;   Is the device in  normal  mode, configured?  bool   isConnected ()   const ;   Is the device in  normal  mode, configured and connected?  const   ConfigStruct   getConfiguration ()   const ;   Get the configuration struct.   Danger  Be careful with this struct, never attempt to change it.   AsyncMqttClient   getMqttClient ();   Get the underlying  AsyncMqttClient  object.  Logger   getLogger ();   Get the underlying  Logger  object, which is only a wrapper around  Serial  by default.", 
            "title": "Functions to call after Homie.setup()"
        }, 
        {
            "location": "/others/cpp-api-reference/#homienode", 
            "text": "HomieNode ( const   char *   id ,   const   char *   type ,   std :: function bool ( const   String   property ,   const   HomieRange   range ,   const   String   value )   handler   =   );   Constructor of an HomieNode object.   id : ID of the node  type : Type of the node  handler : Optional. Input handler of the node   const   char *   getId ()   const ;   Return the ID of the node.  const   char *   getType ()   const ;   Return the type of the node.  PropertyInterface   advertise ( const   char *   property );  PropertyInterface   advertiseRange ( const   char *   property ,   uint16_t   lower ,   uint16_t   upper );   Advertise a property / range property on the node.   property : Property to advertise  lower : Lower bound of the range  upper : Upper bound of the range   This returns a reference to  PropertyInterface  on which you can call:  void   settable ( std :: function bool ( const   HomieRange   range ,   const   String   value )   handler )   =   );   Make the property settable.   handler : Optional. Input handler of the property   SendingPromise   setProperty ( const   String   property );   Using this function, you can set the value of a node property, like a temperature for example.   property : Property to send   This returns a reference to  SendingPromise , on which you can call:  SendingPromise   setQos ( uint8_t   qos );    // defaults to 1  SendingPromise   setRetained ( bool   retained );    // defaults to true  SendingPromise   overwriteSetter ( bool   overwrite );    // defaults to false  SendingPromise   setRange ( const   HomieRange   range );    // defaults to not a range  SendingPromise   setRange ( uint16_t   rangeIndex );    // defaults to not a range  uint16_t   send ( const   String   value );    // finally send the property, return the packetId (or 0 if failure)   Method names should be self-explanatory.", 
            "title": "HomieNode"
        }, 
        {
            "location": "/others/cpp-api-reference/#homiesetting", 
            "text": "HomieSetting T ( const   char *   name ,   const   char *   description );   Constructor of an HomieSetting object.   T : Type of the setting. Either  bool ,  unsigned long ,  long ,  double  or  const char*  name : Name of the setting  description : Description of the setting   T   get ()   const ;   Get the default value if the setting is optional and not provided, or the provided value if the setting is required or optional but provided.  bool   wasProvided ()   const ;   Return whether the setting was provided or not (otherwise  get()  would return the default value).  Set the default value and make the setting optional.  HomieSetting T   setDefaultValue ( T   defaultValue );    defaultValue : The default value   HomieSetting T   setValidator ( std :: function bool ( T   candidate )   validator );   Set a validation function for the setting. The validator must return  true  if the candidate is correct,  false  otherwise.   validator : The validation function", 
            "title": "HomieSetting"
        }, 
        {
            "location": "/others/upgrade-guide-from-v1-to-v2/", 
            "text": "This is an upgrade guide to upgrade your Homie devices from v1 to v2.\n\n\nNew convention\n\n\nThe Homie convention has been revised to v2 to be more extensible and introspectable. Be sure to \ncheck it out\n.\n\n\nAPI changes in the sketch\n\n\n\n\nHomie.setFirmware(name, version)\n must be replaced by \nHomie_setFirmware(name, version)\n\n\nHomie.setBrand(brand)\n must be replaced by \nHomie_setBrand(brand)\n\n\nHomie.registerNode()\n must be removed, nodes are now automagically registered\n\n\nIf you've enabled Serial logging, \nSerial.begin()\n must be called explicitely in your sketch\n\n\nRemove the \nHOMIE_OTA_MODE\n in your event handler, if you have one\n\n\nThe \nHomie.setNodeProperty()\n signature changed completely. If you had \nHomie.setNodeProperty(node, \nproperty\n, \nvalue\n, true)\n, the new equivalent syntax is \nHomie.setNodeProperty(node, \nproperty\n).setRetained(true).send(\nvalue\n)\n. Note the \nsetRetained()\n is not even required as messages are retained by default.\n\n\nTODO", 
            "title": "Upgrade guide from v1 to v2"
        }, 
        {
            "location": "/others/upgrade-guide-from-v1-to-v2/#new-convention", 
            "text": "The Homie convention has been revised to v2 to be more extensible and introspectable. Be sure to  check it out .", 
            "title": "New convention"
        }, 
        {
            "location": "/others/upgrade-guide-from-v1-to-v2/#api-changes-in-the-sketch", 
            "text": "Homie.setFirmware(name, version)  must be replaced by  Homie_setFirmware(name, version)  Homie.setBrand(brand)  must be replaced by  Homie_setBrand(brand)  Homie.registerNode()  must be removed, nodes are now automagically registered  If you've enabled Serial logging,  Serial.begin()  must be called explicitely in your sketch  Remove the  HOMIE_OTA_MODE  in your event handler, if you have one  The  Homie.setNodeProperty()  signature changed completely. If you had  Homie.setNodeProperty(node,  property ,  value , true) , the new equivalent syntax is  Homie.setNodeProperty(node,  property ).setRetained(true).send( value ) . Note the  setRetained()  is not even required as messages are retained by default.  TODO", 
            "title": "API changes in the sketch"
        }, 
        {
            "location": "/others/community-projects/", 
            "text": "This page lists the projects made by the community to work with Homie.\n\n\njpmens/homie-ota\n\n\nhomie-ota is written in Python. It provides an OTA server for Homie devices as well as a simple inventory which can be useful to keep track of Homie devices. homie-ota also enables you to trigger an OTA update (over MQTT, using the Homie convention) from within its inventory. New firmware can be uploaded to homie-ota which detects firmware name (fwname) and version (fwversion) from the uploaded binary blob, thanks to an idea and code contributed by Marvin.\n\n\nstufisher/homie-control\n\n\nhomie-control provides a web UI to manage Homie devices as well as a series of virtual python devices to allow extended functionality.\n\n\nIts lets you do useful things like:\n\n\n\n\nHistorically log device properties\n\n\nSchedule changes in event properties (i.e. water your garden once a day)\n\n\nExecute profiles of property values (i.e. turn a series of lights on and off simultaneously)\n\n\nTrigger property changes based on:\n\n\nWhen a network device is dis/connected (i.e. your phone joins your wifi, turn the lights on)\n\n\nSunset / rise\n\n\nWhen another property changes", 
            "title": "Community projects"
        }, 
        {
            "location": "/others/community-projects/#jpmenshomie-ota", 
            "text": "homie-ota is written in Python. It provides an OTA server for Homie devices as well as a simple inventory which can be useful to keep track of Homie devices. homie-ota also enables you to trigger an OTA update (over MQTT, using the Homie convention) from within its inventory. New firmware can be uploaded to homie-ota which detects firmware name (fwname) and version (fwversion) from the uploaded binary blob, thanks to an idea and code contributed by Marvin.", 
            "title": "jpmens/homie-ota"
        }, 
        {
            "location": "/others/community-projects/#stufisherhomie-control", 
            "text": "homie-control provides a web UI to manage Homie devices as well as a series of virtual python devices to allow extended functionality.  Its lets you do useful things like:   Historically log device properties  Schedule changes in event properties (i.e. water your garden once a day)  Execute profiles of property values (i.e. turn a series of lights on and off simultaneously)  Trigger property changes based on:  When a network device is dis/connected (i.e. your phone joins your wifi, turn the lights on)  Sunset / rise  When another property changes", 
            "title": "stufisher/homie-control"
        }
    ]
}